import { useMemo, useCallback, useEffect } from "react";
import {
    MainContainer,
    // Sidebar, 
    // ConversationList, 
    // Conversation, 
    Avatar,
    ChatContainer,
    ConversationHeader,
    MessageGroup,
    Message,
    MessageList,
    MessageInput,
    TypingIndicator,
    MessageModel
} from "@chatscope/chat-ui-kit-react";

import { useExtendedChat } from "../ExtendedChatProvider";
import {
    // useChat,
    ChatMessage,
    MessageContentType,
    MessageDirection,
    MessageStatus
} from "@chatscope/use-chat";

import { MessageContent, User } from "@chatscope/use-chat";
import { UserMessageContent, UserMessagePhase } from "../open_ai/OpenAITypes";
// import { ReactTyped } from "react-typed";
import { Gender, avatars, openAIModel, openAIConversationId } from "../data/data";
import {
    interPersonalTopicsDictionary,
    InterPersonalTopics,
    TopicCategoryLevel
} from "./inter-personal-topics/InterPersonalTopics";
import { Observation } from "./observation/Observation";
import { FeelingsScale } from "./feelings-scale/FeelingsScale";
import { TypingText } from "./typing-text/TypingText";
import { completeUserPartOfSpeech } from "../open_ai/OpenAIPromptingManager"
import { UserForm } from "./user-form/UserForm";

import mpathicTitle from "../assets/mpathic-family-title.svg";
import "./typing-text/typing-text.css"


export const Chat = ({ user }: { user: User }) => {

    // Get all chat related values and methods from useChat hook 
    const {
        currentMessages, activeConversation, setActiveConversation, sendMessage, addMessage,
        getUser, currentMessage, setCurrentMessage, updateMessage, sendTyping, setCurrentUser,
        currentUser, removeMessagesFromConversation,
        setTopic, setSubTopic, setPhase, removeMessageFromActiveConversation, addOpenAIHistoryText,
        phaseCount, moreUserInputRequired
    } = useExtendedChat();

    useEffect(() => {
        setCurrentUser(user);
    }, [user, setCurrentUser]);

    useEffect(() => {
        setActiveConversation(openAIConversationId)
    }, [setActiveConversation]);


    const scrollToTop = useCallback(() => {
        const timer = setTimeout(() => {
            const msgGroup = document.getElementsByClassName('cs-message-group')[0];

            if (!msgGroup) {
                return;
            }

            msgGroup.scrollIntoView({ behavior: 'auto', block: 'start' });

        }, 200);

        return () => clearTimeout(timer);

    }, [])

    // const scrollToTop = useCallback(() => {
    //     document.getElementsByClassName('cs-message-group')[0]?.scrollIntoView(
    //         { behavior: 'auto', block: 'start' })

    // }, [])

    const scrollToBottom = useCallback(() => {
        document.getElementsByClassName('cs-message-list__scroll-to')[0]?.scrollIntoView({ behavior: 'auto', block: 'end' })
    }, [])

    const addChatBotMsg = useCallback((content: unknown, contentType: MessageContentType) => {
        activeConversation &&
            addMessage(new ChatMessage({
                id: "", // Id will be generated by storage generator, so here you can pass an empty string
                content: content as MessageContent<MessageContentType>,
                contentType: contentType,
                senderId: openAIModel.name,
                direction: MessageDirection.Incoming,
                status: MessageStatus.DeliveredToDevice
            }), activeConversation.id, true);
    }, [activeConversation, addMessage])

    // show chatbot introductory message on mount
    useEffect(() => {
        if (activeConversation && currentMessages.length === 0) {

            if (!currentUser?.data) {
                addChatBotMsg(
                    {
                        message: `תחילה כמה שאלות קטנות שאוכל לתקשר איתך בבהירות`,
                        id: "user_first_registration_msg"
                    }, MessageContentType.Other);

                addChatBotMsg(
                    {
                        active: true,
                        id: "user_first_registration_form"
                    }, MessageContentType.Other);
            }
            else {
                let uName = currentUser?.firstName;
                let uPoS = completeUserPartOfSpeech(currentUser);

                addChatBotMsg(
                    {
                        message: `היי ${uName} :) בחר${uPoS.Yod} נושא עליו תרצ${uPoS.YodOrHei} לדבר או נושא שמעסיק אותך עכשיו`,
                        id: "intro_msg"
                    }, MessageContentType.Other);

                addChatBotMsg(
                    {
                        ...interPersonalTopicsDictionary,
                        active: true,
                        selected: false,
                        selected_categories: null,
                        id: "inter_personal_topics"
                    }, MessageContentType.Other);
            }
        }
    }, [activeConversation, addChatBotMsg, currentMessages.length, currentUser]);

    // Get current user data
    // const [currentUserAvatar, currentUserName] = useMemo(() => {
    //     if (activeConversation) {
    //         const participant = activeConversation.participants.length > 0 ? activeConversation.participants[0] : undefined;
    //         if (participant) {
    //             const user = getUser(participant.id);
    //             if (user) {
    //                 return [<Avatar src={user.avatar} />, user.username]
    //             }
    //         }
    //     }
    //     return [undefined, undefined];
    // }, [activeConversation, getUser]);

    const handleChange = (value: string) => {
        // Send typing indicator to the active conversation
        // You can call this method on each onChange event
        // because sendTyping method can throttle sending this event
        // So typing event will not be send to often to the server
        setCurrentMessage(value);
        if (activeConversation) {
            sendTyping({
                conversationId: activeConversation?.id,
                isTyping: true,
                userId: user.id,
                content: value, // Note! Most often you don't want to send what the user types, as this can violate his privacy!
                throttle: true
            });
        }
    }

    const createUserMessage = useCallback((text: string): ChatMessage<any> => {
        return new ChatMessage({
            id: "", // Id will be generated by storage generator, so here you can pass an empty string
            // content: text as unknown as MessageContent<TextContent>,
            content: { user_text: text } as UserMessageContent,
            contentType: MessageContentType.Other,
            senderId: user.id,
            direction: MessageDirection.Outgoing,
            status: MessageStatus.Sent
        });
    }, [user.id])

    // JUST ADD USER MESSAGE WITHOUT SENDING IT FORWARDED TO THE SERVER
    const addUserMsg = useCallback((text: string) => {
        activeConversation &&
            addMessage(createUserMessage(text), activeConversation.id, true);
    }, [activeConversation, addMessage, createUserMessage])


    const doSend = (text: string) => {
        handleSend('', text)
    }

    const handleSend = (innerHtml: string, text: string) => {

        // let nextUserPhase = nextUserPhaseByHistory();

        const message = createUserMessage(text);

        if (activeConversation) {
            sendMessage({
                message,
                conversationId: activeConversation.id,
                senderId: user.id,
            });
        }
    };


    const getTypingIndicator = useCallback(
        () => {
            if (activeConversation) {
                const typingUsers = activeConversation.typingUsers;
                if (typingUsers.length > 0) {
                    const typingUserId = typingUsers.items[0].userId;
                    // Check if typing user participates in the conversation
                    if (activeConversation.participantExists(typingUserId)) {
                        const typingUser = getUser(typingUserId);
                        if (typingUser) {
                            if (typingUserId === openAIModel.name)
                                return <TypingIndicator content={`${typingUser.username} is replying`} />
                            else
                                return <TypingIndicator content={`${typingUser.username} is typing`} />
                        }
                    }
                }
            }
            return undefined;

        }, [activeConversation, getUser],
    );

    const createMessageModel =
        (chat_msg: ChatMessage<MessageContentType>) => {
            // let uName = user?.firstName;
            let uGender = user?.data?.gender;
            let uPoS = completeUserPartOfSpeech(user);

            let message_type;
            let message_payload;
            if (chat_msg.direction === MessageDirection.Incoming) {

                if (chat_msg.status === MessageStatus.DeliveredToDevice &&
                    chat_msg.contentType === MessageContentType.TextPlain) {

                    message_type = "custom";
                    message_payload = <TypingText
                        chatMsg={chat_msg}
                        chatMsgContentToStrings={(c: Object) => { return [c as string] }}
                        onStringTyped={() => {
                            scrollToBottom()
                        }} />
                }
                else if (chat_msg.status === MessageStatus.DeliveredToDevice &&
                    chat_msg.contentType === MessageContentType.Other) {

                    message_type = "custom";
                    let obj = Object(chat_msg.content)

                    if (obj.id === "user_first_registration_msg") {

                        // a separate module should be implemented instaed displaying just typed text 
                        message_payload =
                            <TypingText
                                chatMsg={chat_msg}
                                chatMsgContentToStrings={(c: Object) => {
                                    return [Object(c).message]
                                }}
                                onStringTyped={() => {
                                    scrollToTop()
                                }}
                            />
                    }
                    else if (obj.id === "user_first_registration_form") {
                        message_payload =
                            <UserForm onSubmit={(data) => {
                                user.firstName = data.firstName;
                                user.data = { age: data.age, gender: data.gender };
                                user.avatar = avatars[data.gender];
                                setCurrentUser(user)
                                removeMessagesFromConversation(activeConversation?.id as string)
                            }} />
                    }
                    else if (obj.id === "intro_msg") {

                        // a separate module should be implemented instaed displaying just typed text 
                        message_payload =
                            <TypingText
                                chatMsg={chat_msg}
                                chatMsgContentToStrings={(c: Object) => {
                                    return [Object(c).message]
                                }}
                                onStringTyped={() => {
                                    // scrollToTop()
                                }}
                            />
                    }
                    else if (obj.id === "inter_personal_topics") {

                        message_payload =
                            <InterPersonalTopics
                                topics={obj.major_categories}
                                active={obj.active}
                                selected={obj.selected}
                                selectedCategories={obj.selected_categories}
                                doOnRender={scrollToTop}
                                onTopicSelection={(selected_categories) => {
                                    let topic = ' כללי';
                                    let subTopic = '';

                                    if (selected_categories.level === TopicCategoryLevel.Level_1) {
                                        topic = selected_categories.topics_titles[0]
                                        setTopic(topic)
                                    }
                                    else if (selected_categories.level === TopicCategoryLevel.Level_2) {
                                        topic = selected_categories.topics_titles[0]
                                        subTopic = selected_categories.topics_titles[1]
                                        setTopic(topic)
                                        setSubTopic(subTopic)
                                    }

                                    removeMessageFromActiveConversation(chat_msg.id)
                                    addUserMsg(
                                        topic === '' ? `הסיטואציה קשורה לנושא כללי` : `הסיטואציה קשורה לנושא ${topic}`
                                            + (subTopic === '' ? `` : ` ובפרט לגבי ${subTopic}`));

                                    setPhase(UserMessagePhase.PersonInConflictIdentity)
                                    addChatBotMsg(`מי האדם אליו ${uPoS.sbj2ndPronoun} מתייחס${uPoS.Taf} (לדוגמא ${uGender === Gender.Male ? "בת זוג" : "בן זוג"}, אח אחות וכולי) ומה שמו/שמה ?`, MessageContentType.TextPlain)
                                }}
                            />
                    }
                    else if (obj.id === "observation") {

                        // a separate module should be implemented instaed displaying just typed text 
                        message_payload =
                            <Observation
                                active={obj.active}
                                isCorrect={obj.isCorrect}
                                text={obj.observation}
                                onCorrectClick={() => {
                                    obj.isCorrect = true;
                                    obj.active = false;
                                    addOpenAIHistoryText("assistant", obj.observation);
                                    updateMessage(chat_msg);
                                    addChatBotMsg(`כעת בבקשה פרט קצת יותר על התחושות שלך בנוגע לכל מה שקרה`, MessageContentType.TextPlain)
                                    setPhase(UserMessagePhase.FeelingsProbe)
                                }}
                                onNotAccurateClick={() => {
                                    obj.isCorrect = false;
                                    obj.active = false;
                                    updateMessage(chat_msg);
                                    addChatBotMsg(phaseCount <= 1 ? `בבקשה תדייק.י את מה שכתבתי. אגב, אני בכוונה מנסה להתנסח בצורה חסרת שיפוטיות, מכיוון שאני לוקח השראה מתקשורת מקרבת :) וחשוב לי להבין כרגע את העובדות` : `בבקשה תדייק יותר`, MessageContentType.TextPlain)
                                    setPhase(UserMessagePhase.ObservationAnalysis)
                                }}
                            />
                    }
                    else if (obj.id === "feelings") {

                        message_payload =
                            <FeelingsScale feelings={obj.feelings} active={obj.active}
                                onRescaleDone={(new_feelings, prompt_msg) => {
                                    obj.active = false
                                    obj.feelings = new_feelings
                                    updateMessage(chat_msg)
                                    doSend(prompt_msg)
                                }}
                            />
                    }
                }
                else if (chat_msg.status === MessageStatus.Sent &&
                    chat_msg.contentType === MessageContentType.Other) {

                    let obj = Object(chat_msg.content)
                    if (["intro_msg", "user_first_registration_msg"].includes(obj.id)) {
                        message_type = "text";
                        message_payload = obj.message;
                    }
                }
                else {

                    message_type =
                        chat_msg.contentType === MessageContentType.Other ? "custom" :
                            chat_msg.contentType === MessageContentType.TextHtml ? "html" :
                                chat_msg.contentType === MessageContentType.Image ? "image" :
                                    chat_msg.contentType === MessageContentType.TextPlain ? "text" :
                                        "";
                    message_payload = chat_msg.content

                }
            }
            else if (chat_msg.direction === MessageDirection.Outgoing) {
                message_type = "text";
                message_payload = (chat_msg.content as UserMessageContent).user_text;
            }

            let model = {
                type: message_type,
                payload: message_payload,
                direction: chat_msg.direction,
                position: "normal"
            }
            return model as MessageModel;
        };

    // const oppositeMsgDirection = useCallback(
    //     (d: MessageDirection) => {
    //         if (d === MessageDirection.Incoming)
    //             return MessageDirection.Outgoing
    //         else return MessageDirection.Incoming
    //     }, []
    // )

    const toHoldTextInput = () => {

        for (let g of currentMessages) {
            for (let msg of g.messages) {
                if (msg.status === MessageStatus.DeliveredToDevice &&
                    msg.contentType === MessageContentType.Other &&
                    Object(msg.content).active) {
                    return true
                }
            }
        }

        return false
    }

    const getMsgCustomizedContentClasses = (m: ChatMessage<MessageContentType>) => {
        return (Object(m.content).id === "inter_personal_topics" ? 'card-message' : '').trim();
    }

    const rtl = process.env.REACT_APP_RTL
    const hold_text_input = toHoldTextInput()

    return (
        <MainContainer responsive>

            <ChatContainer>
                {activeConversation && <ConversationHeader>
                    {<Avatar size="fluid" src={mpathicTitle} />}
                </ConversationHeader>}

                <MessageList
                    typingIndicator={getTypingIndicator()}
                // autoScrollToBottom={true} 
                // autoScrollToBottomOnMount={false} 
                // scrollBehavior={"auto"}
                >

                    {activeConversation && currentMessages.map((g) =>
                        <MessageGroup key={g.id}
                            direction={g.direction}>
                            <Avatar src={user.id === g.senderId ? user.avatar : getUser(g.senderId)?.avatar} />
                            <MessageGroup.Messages>
                                {g.messages.map((m: ChatMessage<MessageContentType>) =>
                                    <Message
                                        key={m.id}
                                        model={createMessageModel(m)}
                                        className={(`${getMsgCustomizedContentClasses(m)}`).trim()} />)}
                            </MessageGroup.Messages>
                        </MessageGroup>)}
                </MessageList>
                <MessageInput
                    value={currentMessage}
                    onChange={handleChange}
                    onSend={handleSend}
                    disabled={!activeConversation || hold_text_input}
                    attachButton={false}
                    placeholder={rtl === 'yes' ? "הקלד כאן ..." : "Type here..."} />
            </ChatContainer>

        </MainContainer>
    );

}